Implementing Plaid Transfer for the ShiFi Platform (Node.js Guide)

This guide provides a comprehensive walkthrough for integrating Plaid Transfer into the ShiFi platform using Node.js. ShiFi is a fintech platform facilitating payments between customers and merchants. In some cases, ShiFi itself finances a purchase (buying a payment plan from the merchant), so funds may flow either directly to a merchant or to ShiFi. We will cover both one-time and recurring transfers, using Plaid’s Transfer API and an existing Plaid Link + Auth integration. You’ll learn how to set up the flow of funds for both scenarios (customer→merchant and customer→ShiFi), handle webhooks and errors, manage refunds/cancellations, and perform reconciliation. Optional enhancements like Plaid’s Transfer UI and platform partner features are also discussed.

Prerequisites and Setup

Before coding the transfer logic, make sure you have the following in place:
	•	Plaid Account and API Keys: Ensure you have Plaid API credentials (client ID and secret) with the Transfer product enabled. You can obtain these from your Plaid dashboard ￼ ￼.
	•	Plaid Node.js SDK: Install Plaid’s official Node.js client library. For example, using npm: npm install plaid. Initialize the client with your keys and desired Plaid environment (Sandbox for testing, Development/Production for live):

const plaid = require('plaid');
const client = new plaid.PlaidApi(new plaid.Configuration({
  basePath: plaid.PlaidEnvironments.sandbox,  // or .development / .production
  baseOptions: {
    headers: {
      'PLAID-CLIENT-ID': process.env.PLAID_CLIENT_ID,
      'PLAID-SECRET': process.env.PLAID_SECRET,
    },
  },
}));


	•	Existing Plaid Link integration with Auth: ShiFi already uses Plaid Link with the Auth product to collect users’ bank account and routing numbers. We will leverage that integration to obtain an access_token and account_id for the user’s bank account. If you haven’t enabled the Transfer product in Link, update your Link token creation to include "transfer" in the products array (in addition to "auth"). This ensures the linked Item is enabled for money movement ￼. The basic Link flow is:
	1.	Call /link/token/create with products: ["auth", "transfer"] (or add "transfer" if Auth is already used) ￼.
	2.	Launch Link for the user to select and connect their bank account.
	3.	On success, retrieve the public_token and exchange it for an access_token (via /item/public_token/exchange), and get the selected account_id ￼.
	•	Migrating existing bank accounts (if needed): If some user accounts were linked with Auth without Transfer, you can still use them for Transfer by calling the /transfer/migrate_account endpoint with the known account and routing numbers ￼. This will create a Plaid Item that’s usable with Transfer (your Plaid account manager may need to enable this feature).

Platform Configuration (ShiFi as a Partner Platform)

Since ShiFi is a platform that facilitates payments for third-party merchants, you should configure Plaid’s Platform Payments features (if you are in Plaid’s beta program for reseller partners). This setup allows ShiFi to onboard merchants as originators and optionally keep funds segregated per merchant. Key points for platform setup:
	•	Originators (Merchants) Onboarding: Each merchant using ShiFi can be registered as an originator in Plaid. In Sandbox or testing, you can create an originator via the /transfer/originator/create endpoint ￼. In Production, Plaid offers a KYB (Know Your Business) onboarding flow via a hosted questionnaire. The typical steps are:
	1.	Create a customer (merchant) record: call /partner/customer/create (with auth in products) and then /partner/customer/enable. This generates an end_customer.client_id for the merchant ￼.
	2.	Send KYB questionnaire: use /transfer/questionnaire/create to get a Plaid-hosted URL and have the merchant complete the onboarding form ￼ ￼.
	3.	Approval: Poll /transfer/originator/get for status ￼. Once approved, the merchant is assigned an originator_client_id (usually the same as the end_customer.client_id in sandbox).
	•	Originator Funding Accounts: After onboarding, attach the merchant’s payout bank account as a funding account record. Call /transfer/originator/funding_account/create with the merchant’s bank account details or a processor token ￼. This links the merchant’s bank account to Plaid’s transfer network.
	•	Using Originator IDs in API calls: When making transfer API calls on behalf of a merchant, include the originator_client_id parameter. Most Transfer endpoints accept this to indicate which originator (merchant) the transfer is for ￼. One important detail is that Linking end-user accounts for transfers in a platform context should use the end-customer’s own Plaid API keys. In other words, when your platform prompts a user (payer) to link their bank, you should supply the merchant’s client ID & secret to create the Link token ￼. But for creating transfers and other operations, use your platform’s API keys along with the originator_client_id of the merchant. This way, Plaid knows which ledger/originator the funds belong to.

Note: If you are not in the Platform Payments beta, you can still handle multiple parties by managing the flow of funds through ShiFi’s own account (see the “Flow of Funds” section below). Platform Payments simply streamlines this with segregated ledgers per originator, but the underlying transfer steps remain similar ￼ ￼.

Flow of Funds: Customer→Merchant vs Customer→ShiFi

Understanding the money movement is crucial. ShiFi has two primary payment flows:
	•	Direct Payment to Merchant: The customer’s bank account is debited and the merchant’s bank account is credited. ShiFi facilitates this transfer but does not retain the funds.
	•	Payment Plan (ShiFi Financing): ShiFi pays the merchant up front (crediting the merchant’s account from ShiFi’s funds), and then the customer’s bank account is debited (immediately or in installments) to repay ShiFi.

Plaid Transfer can handle both scenarios:

1. Customer pays Merchant (One-Time): In a platform context, this can be executed as a single debit transfer from the customer with the merchant as the originator. Under the hood, Plaid will pull money from the customer into ShiFi’s clearing account and then sweep it to the merchant’s account (if using the legacy flow) or credit the merchant’s ledger directly (if using Platform Payments). You can also choose to implement it in two steps (debit then credit) if not using originator features:
	•	Debit Step: Debit the customer’s account into ShiFi’s account.
	•	Credit Step: After the debit settles, issue a credit transfer to the merchant’s account.

Using the originator approach is simpler as Plaid will move funds to the merchant’s linked account automatically once the debit clears. We’ll demonstrate the single-step approach using originators in code shortly.

2. ShiFi-financed Plan: Here ShiFi initially pays the merchant, and the customer owes ShiFi. This involves:
	•	Payout to Merchant: a credit transfer from ShiFi to the merchant’s bank (i.e. from ShiFi’s business account to the merchant’s account). ShiFi might do this as soon as the plan is purchased.
	•	Collection from Customer: a debit transfer from the customer’s bank to ShiFi’s account. If the plan involves installments, this could be a recurring transfer (multiple debits on a schedule) from the customer to ShiFi.

In this scenario, funds flow into ShiFi (instead of to the merchant) when the customer pays. ShiFi’s account is the beneficiary of those debits.

Next, we will go through implementing one-time transfers (covering both debit and credit types), then set up recurring transfers for installment payments.

Initiating a One-Time Transfer (Authorization & Creation)

Plaid’s Transfer API uses a two-step process for any transfer: authorization and creation. Authorization performs a risk check (and balance check) to decide if the transfer is allowed, while creation actually schedules the ACH transfer. We must call /transfer/authorization/create first, then /transfer/create.

1. Create a Transfer Authorization

Use the Plaid Node client to create a transfer authorization. You will need to specify: the access_token of the user’s bank item, the target account_id for that item, the type of transfer ("debit" or "credit"), the network ("ach" for ACH transfers), the transfer amount, ACH class (usually "ppd" for consumer personal transfers or "ccd" for business payments), and user information (at least the legal name). If you are using Platform Payments with originators, also include the originator_client_id of the merchant for whom this transfer is being done (in direct customer→merchant payments).

Below is an example of creating a transfer authorization in Node.js. This example assumes we are debiting a customer’s account for a $100 payment to a merchant (thus type: "debit"). If instead ShiFi was paying out to a merchant, we would use type: "credit" and likely swap which account we identify as the target:

// Example: Authorize a $100 debit from customer (accessToken, accountId) 
// to merchant (originator's funding account) via ACH
async function authorizeTransfer(customerAccessToken, customerAccountId, originatorId) {
  try {
    const authRequest = {
      access_token: customerAccessToken,
      account_id: customerAccountId,
      type: "debit",              // "debit" for pulling funds from user; "credit" for pushing to user
      network: "ach",             // ACH transfer; could also be "same-day-ach" or "rtp" if enabled
      amount: "100.00",           // amount in USD as a string
      ach_class: "ppd",           // PPD for personal account debit (WEB could be used for online auth as well)
      user: {
        legal_name: "Jane Doe",   // User's name; ideally match account holder name
        email: "jane@example.com",
        // phone etc. could be included if available
      },
      originator_client_id: originatorId  // specify merchant originator (if using platform payments)
    };
    const authResponse = await client.transferAuthorizationCreate(authRequest);
    const decision = authResponse.data.authorization.decision;
    if (decision !== 'approved') {
      console.log("Transfer authorization was not approved:", authResponse.data.authorization);
      // Handle 'declined' or 'user_action_required' scenarios
      return null;
    }
    const authorizationId = authResponse.data.authorization.id;
    return authorizationId;
  } catch (error) {
    console.error("Error creating transfer authorization:", error.response?.data || error);
    throw error;
  }
}

A few notes on handling the authorization response:
	•	If authorization.decision == "approved", you may proceed. If a rationale_code is present (e.g. MANUALLY_VERIFIED_ITEM or ITEM_LOGIN_REQUIRED), Plaid couldn’t fully risk-assess, and you should do extra risk checks or prompt the user to update their bank link ￼ ￼.
	•	If decision == "declined", Plaid has flagged the transfer (e.g. risk or user’s balance too low). You cannot create the transfer. You might inform the user or try a smaller amount. Common decline reasons include NSF (insufficient funds) or risk rules ￼.
	•	If decision == "user_action_required", the user’s bank link needs updating (for example, multi-factor auth or re-login is required) ￼. You should prompt the user to re-open Plaid Link in update mode to resolve this. Plaid provides a special way to do this: create a new Link token with transfer.authorization_id from above and have the user complete the needed steps ￼. After that, retry the authorization.

In our example above, we simply log and stop if not approved. In a real app, implement the flows for user_action_required (re-link user) or gracefully handle declines.

2. Create the Transfer

Once you have an approved authorization_id, you can create the transfer itself. This reserves the amount against your transfer limits and schedules the ACH transaction in Plaid’s system. Here’s how to call /transfer/create using Node.js:

async function createTransfer(customerAccessToken, customerAccountId, authorizationId, originatorId) {
  try {
    const transferRequest = {
      access_token: customerAccessToken,
      account_id: customerAccountId,
      authorization_id: authorizationId,
      description: "ShiFi Payment #12345",  // This will appear in the bank statement descriptor
      originator_client_id: originatorId    // merchant originator (if applicable)
    };
    const transferResponse = await client.transferCreate(transferRequest);
    const transfer = transferResponse.data.transfer;
    console.log("Created transfer:", transfer.id, "Status:", transfer.status);
    return transfer.id;
  } catch (error) {
    console.error("Error creating transfer:", error.response?.data || error);
    throw error;
  }
}

A few things happening in this code:
	•	We pass the same access_token and account_id (customer’s account for a debit). The authorization_id obtained from the previous step is required to actually create the transfer.
	•	The description is a free-text field you set. It will be part of the ACH descriptor that the user (or merchant) sees on their bank statement. Typically, bank statements show a combination of your company name, phone, and this description ￼ ￼. For example, if your company name is “ShiFi Inc” and the description is “ShiFi Payment #12345”, a user’s bank might list something like “SHIFI INC 800-123-4567 ShiFi Payment #12345” in their transaction detail.
	•	We include originator_client_id if this transfer is meant to go to a specific merchant’s ledger. For a customer→merchant direct payment, use the merchant’s originator ID. For a customer→ShiFi payment (e.g. installment to ShiFi), you might use your own platform’s originator ID or omit it (funds will default to the platform’s ledger).
	•	The response will contain a transfer object, including a unique transfer_id and initial status (likely "pending"). Save this transfer_id in your database along with the associated order or transaction.

Funds Flow on Transfer Creation: At this point, Plaid will queue the transfer for the next ACH processing window. The status will progress from pending → posted → settled over time (assuming no issues). If it’s a debit, the funds are pulled from the user and held by Plaid’s system until they clear; if it’s a credit, funds will be pulled from your linked business account to be sent out. The actual movement of money between bank accounts happens during ACH processing windows, explained next.

ACH Processing Windows and Timeline

ACH transfers do not move instantly; they are processed in batches during banking days. Plaid’s Transfer API automatically routes your transfer into the appropriate batch:
	•	Next-Day ACH: If you create a transfer before 8:30 PM Eastern on a business day, it will go out in that day’s batch for next-day settlement ￼. Creating after 8:30 PM (but before the day’s end) will queue it for the next business day’s batch.
	•	Same-Day ACH: If your Plaid account supports same-day ACH, transfers created before 3:30 PM Eastern can go out same-day ￼. Between 3:30 and 8:30 PM, Plaid will automatically fall back to next-day processing ￼.
	•	Weekends and Holidays: No ACH processing occurs on weekends or Federal holidays. Any transfers created during those times will wait until the next business day to be sent ￼. It’s wise to account for this in your UI (e.g., inform users of next available processing day if they pay on a weekend).
	•	Status Updates: Initially, your transfer is pending. Once Plaid submits it in a batch, the status becomes posted. Settlement (funds actually moving) typically happens the next business day for ACH. When complete, status changes to settled. For ACH debits, Plaid will mark funds_available when those funds are cleared for you to use (which can be on settlement or a bit later). You’ll track these via webhooks/events (discussed soon).

In summary, to guarantee a transfer goes out the same day, call /transfer/create by ~3:15 PM ET; for next-day, by ~8:15 PM ET ￼. Otherwise, expect a delay. Keep in mind the transfer limits assigned to you as well (daily/monthly caps), which Plaid will enforce – a transfer auth that would exceed your limit will be declined with a TRANSFER_LIMIT_REACHED rationale ￼ ￼.

One-Time Transfer Example Flow

Putting it all together, here’s a simplified end-to-end example for a customer→merchant payment of $100, assuming we have all IDs ready and using an originator:

// Pseudocode illustrating a one-time payment flow
const accessToken = "...";      // from Link flow
const accountId = "...";        // from Link selected account
const merchantOriginatorId = "...";  // obtained during merchant onboarding

// 1. Authorize the transfer
const authId = await authorizeTransfer(accessToken, accountId, merchantOriginatorId);
if (!authId) {
  return res.status(400).send("Transfer not authorized");
}

// 2. Create the transfer
const transferId = await createTransfer(accessToken, accountId, authId, merchantOriginatorId);
console.log("Transfer initiated with ID:", transferId);

// 3. (optional) Send response or update order status
res.send({ success: true, transferId });

At this point, money will be pulled from the customer’s bank in the next ACH window. If using Platform Payments, Plaid will automatically credit the merchant’s linked account once the debit clears (Plaid handles the internal “sweep” to the merchant). If not using platform mode, the funds will land in ShiFi’s business account (your clearing account) and you’d then separately initiate a payout transfer to the merchant. In either case, you should monitor the transfer’s status via webhooks for confirmation and handle any failures, which we’ll cover next.

Setting Up Recurring Transfers (Installments)

For installment plans or recurring payments (such as monthly subscriptions or multi-part payment plans), Plaid offers a Recurring Transfers feature. This allows you to schedule a series of ACH transfers based on a fixed interval, without having to manually trigger each one. Once a recurring transfer is scheduled, Plaid will automatically create each occurrence on the specified schedule ￼.

Important: Recurring transfers are not supported in Platform Payments mode ￼. If you’re using originators for merchants, you may need to handle recurring logic in your own code (e.g. store schedule and call one-time transfers for each installment). However, if the recurring payments are going to ShiFi itself (e.g. customer repaying ShiFi), you can use recurring transfers since ShiFi is the platform (no originator_client_id needed in that case).

To create a recurring transfer via the API, you will call /transfer/recurring/create. The parameters are similar to a normal authorization, plus a schedule object. The process under the hood is that Plaid will authorize the entire series up front and create each individual transfer at the right time.

Scheduling a Recurring Transfer

Define a schedule with:
	•	interval_unit: either "week" or "month" (currently Plaid supports weekly or monthly intervals).
	•	interval_count: the number of units between transfers. For example, interval_unit "week" and interval_count 2 means every 2 weeks ￼.
	•	interval_execution_day: the day on which to execute the transfer:
	•	For weekly, use 1 for Monday through 5 for Friday (business days) ￼.
	•	For monthly, use 1-28 for a specific date or negative values for end-of-month (e.g. -1 = last day of month, -2 = second last day) ￼.
	•	start_date: the first date on which a transfer should be made (ISO format YYYY-MM-DD). If this date doesn’t fall on the specified execution day (e.g. not the right weekday), Plaid will adjust to the next valid day.
	•	end_date (optional): last date (inclusive) for the schedule. If omitted, the recurring series will continue until canceled ￼. If an occurrence would fall after the end_date, it will not be created.

With the schedule set, the other fields (access_token, account_id, type, network, amount, ach_class, description, user info) are the same as for a one-time transfer auth. Note that the amount is the amount for each occurrence.

Recurring Transfer Creation Example

Suppose we want to charge a customer $50 on the 1st of each month for 6 months (e.g. a 6-month installment plan), starting in January. Here’s how we might create that recurring transfer in Node:

async function createRecurringTransfer(accessToken, accountId) {
  const schedule = {
    interval_unit: "month",
    interval_count: 1,             // every 1 month
    interval_execution_day: 1,     // 1st day of the month
    start_date: "2025-01-01",
    end_date: "2025-06-01"         // last occurrence in June (inclusive)
  };
  const recurringRequest = {
    access_token: accessToken,
    account_id: accountId,
    type: "debit",
    network: "ach",
    amount: "50.00",
    ach_class: "ppd",
    description: "ShiFi Plan Installment",
    user: { legal_name: "Jane Doe" },
    schedule: schedule
    // (originator_client_id can be included if funds are going to a specific originator.
    // In this example, assume ShiFi is collecting the installment, so no originator_id needed.)
  };
  try {
    const response = await client.transferRecurringCreate(recurringRequest);
    const recurringId = response.data.recurring_transfer.recurring_transfer_id;
    console.log("Recurring transfer scheduled with ID:", recurringId);
    return recurringId;
  } catch (error) {
    console.error("Error creating recurring transfer:", error.response?.data || error);
    throw error;
  }
}

This call will immediately perform an authorization for the first scheduled transfer. If approved, it returns a recurring_transfer_id that represents the series. Plaid will then automatically originate a $50 transfer on Feb 1, Mar 1, etc. up to June 1.

Managing Recurring Transfers: You can cancel a recurring schedule anytime by calling /transfer/recurring/cancel with the recurring_transfer_id ￼. Canceling on the day of a scheduled transfer might not stop that day’s transfer if it’s already in process ￼. Also, Plaid will emit special webhook events for recurring transfers:
	•	RECURRING_NEW_TRANSFER: when a new transfer instance is created as part of the schedule ￼.
	•	RECURRING_CANCELLED: if the schedule is canceled (e.g. by Plaid due to too many failures) ￼.
	•	RECURRING_TRANSFER_SKIPPED: if a scheduled occurrence could not be created (for example, if it fell beyond end_date or another issue) ￼.

Be sure to handle these in your webhook processor (more on webhooks next). Each actual transfer from a recurring series will also go through the normal statuses and events.

Weekend/Holiday adjustments: If a scheduled date falls on a non-business day, Plaid will automatically move it to the next business day (provided it’s not beyond end_date) ￼. This ensures transfers only occur on valid banking days.

Webhook Integration for Transfers

To keep your system in sync with transfer statuses (and to react to events like returns or cancellations promptly), set up a Plaid webhook for Transfer events. Webhooks allow Plaid to notify your application whenever something important happens with a transfer or sweep.

Registering the Webhook

In your Plaid Dashboard under Team Settings or Webhook settings, register a new webhook URL for the Transfer product ￼. Plaid will send HTTP POST requests to this URL when there are updates. For development, you can use a tool like ngrok to expose your local server and capture webhooks.

Plaid’s Transfer webhooks use a “pull” model: they tell you that events are available, but not all details in the webhook itself. Specifically, when new events occur, you’ll get a webhook with webhook_type: "TRANSFER" and webhook_code: "TRANSFER_EVENTS_UPDATE" ￼. The webhook body does not list each event; it’s essentially a nudge for your server to fetch events.

Example webhook payload (trimmed for clarity):

{
  "webhook_type": "TRANSFER",
  "webhook_code": "TRANSFER_EVENTS_UPDATE",
  "environment": "sandbox"
}

This indicates one or more transfer events have occurred.

Handling Webhook Events (Node.js)

Your webhook endpoint should respond quickly (within a few seconds). It can asynchronously fetch the events. Plaid provides two endpoints to retrieve events:
	•	/transfer/event/sync: get events since the last seen event (this is ideal for continuous sync) ￼.
	•	/transfer/event/list: query events by transfer_id, event types, or other filters (useful for specific lookup) ￼.

A common approach is to use transfer/event/sync with an after_id parameter. You maintain a pointer to the last processed event ID. On webhook, call event/sync to get new events after that ID ￼. The response gives you up to 25 events (or a count you specify) and a next_cursor (latest event ID). You then update your stored pointer.

Here’s a simplified Express.js webhook handler that uses event sync:

app.post("/plaid-webhook", async (req, res) => {
  const body = req.body;
  if (body.webhook_type === "TRANSFER" && body.webhook_code === "TRANSFER_EVENTS_UPDATE") {
    try {
      // Retrieve new transfer events since last seen
      const afterId = getLastProcessedEventId();  // your function to retrieve last saved event ID
      const eventsResp = await client.transferEventSync({ after_id: afterId || 0 });
      const events = eventsResp.data.transfer_events;
      events.forEach(event => {
        console.log(`Transfer event: ID=${event.event_id}, Type=${event.event_type}, TransferID=${event.transfer_id}`);
        handleTransferEvent(event);  // your logic to handle each event
      });
      // Save the new last processed event ID
      const newLastId = eventsResp.data.latest_event_id;
      saveLastProcessedEventId(newLastId);
    } catch (err) {
      console.error("Failed to sync transfer events:", err.response?.data || err);
    }
  }
  // Respond quickly to acknowledge
  res.sendStatus(200);
});

In the above:
	•	We check that webhook_type is TRANSFER and webhook_code is TRANSFER_EVENTS_UPDATE.
	•	We use a hypothetical getLastProcessedEventId to get the ID of the last event we handled (store this in a DB or in memory). If none, we can start from 0 to get recent events.
	•	Call client.transferEventSync({ after_id: lastEventId }). If after_id is omitted or 0, Plaid will return recent events up to the default count (so be careful on first use). You might instead use a fixed cursor initially.
	•	Iterate over transfer_events in the response. Each event will have:
	•	event_id – the unique ID for this event.
	•	event_type – e.g. pending, posted, settled, failed, returned, etc for transfers, or sweep.* for sweeps ￼ ￼.
	•	transfer_id – which transfer this event is about.
	•	sweep_id or refund_id if applicable, for sweep or refund events.
	•	transfer_type (debit/credit) and other metadata.
	•	Acknowledge the webhook by responding 200 ASAP (before or after processing, but within a few seconds).

Event handling logic: In handleTransferEvent(event), you’ll update your records or take actions:
	•	If event.event_type == "posted" for a transfer, it means the ACH entry was submitted. Not much to do, but you know it’s in flight.
	•	If settled, the transfer completed. For a credit to merchant, this means the merchant got the funds. You can mark an order as paid out. For a debit from customer, settled means money has been pulled from the customer; if it’s going to ShiFi, you might now provide service or mark their installment as paid.
	•	If returned, the transfer bounced back (ACH return). The event will include a return_code and possibly return_reason. For example, R01 is insufficient funds, R03 no account/unable to locate, R02 account closed, etc. You should notify the relevant parties and perhaps retry or cancel the related order. Returned debits mean the money never actually was received (if it was a debit from a customer, you don’t have the funds; if it was a credit to a merchant, the merchant likely didn’t get it either because it was pulled back).
	•	If failed, it usually means Plaid couldn’t even initiate the transfer (rare, maybe due to internal error or compliance). Treat it similar to a decline.
	•	If cancelled, a transfer was cancelled (by you or Plaid) before completion.
	•	sweep.posted or sweep.failed events relate to moving funds between Plaid’s clearing and your business bank (see Reconciliation section). You might log these or use them for accounting.

Plaid’s docs have a full list of event types and how they map to transfer status ￼ ￼. The key is to keep your database in sync with the latest status so you know the outcome of each transfer. For instance, you might have a payments table with a status that you update when you see a transfer settled or returned.

Reconciliation and Sweeping of Funds

Because Plaid sits in the flow of funds for ACH, the money from many individual transfers will be aggregated and moved into or out of your business bank account in lumps called sweeps. A sweep is a transfer of funds between Plaid’s ledger (which holds funds in flight) and your actual bank account ￼.

For example, if five customers each pay $100 to ShiFi on the same day, Plaid might group those into one $500 credit sweep into your business account once the debits settle, rather than five separate bank deposits. Conversely, if you send out payouts, Plaid might pull the total amount from your account in one sweep.

To reconcile your bank statements with Plaid activity:
	•	Use the /transfer/sweep/list or /transfer/sweep/get endpoints to retrieve sweep records ￼ ￼. Each sweep has a sweep_id and amount.
	•	Plaid ensures the first 8 characters of the sweep_id appear in your bank statement description ￼. For instance, your statement might show entries like:
	•	PLAID 6C036EA0 CCD $5,264.62 on a certain date,
	•	PLAID AE42C210 CCD $2,367.80 on another date, etc.
Those hex strings (e.g. 6C036EA0) correspond to a sweep ID, which you can then query via the API or find in the Plaid dashboard ￼. This makes it easier to match bank deposits/withdrawals with the individual transfers that contributed to them.
	•	When a sweep occurs, Plaid will also send a webhook event like sweep.posted with the sweep information. Monitoring these can inform you when funds have actually moved into/out of your bank.
	•	Reconciliation report: In the Plaid Dashboard’s Transfer section, you can also export a CSV report of transfers and sweeps ￼. This can be useful for cross-checking your internal records.

By reconciling regularly, you ensure that all transfers that show as settled in Plaid correspond to actual bank transactions in ShiFi’s accounts. This helps catch any discrepancies early.

Refunds and Cancellations

In payments, situations may arise where you need to cancel a transfer or refund a customer. Plaid Transfer supports both actions under certain conditions.

Cancelling a Transfer

Before it’s sent out: If you realize you need to stop a transfer (e.g. user cancels an order right after initiating payment), you can attempt to cancel it via /transfer/cancel. This requires the transfer_id. A transfer that is still in pending status and marked as cancellable can often be canceled ￼. In practice, ACH transfers can usually be canceled if you act before they are batched/sent (once it’s posted or in flight, you can’t cancel).

For instant transfers (RTP/FedNow) if you ever use those, cancellation is not possible because they send in real-time ￼. For ACH, use /transfer/get to check cancellable property if in doubt ￼.

To cancel in Node:

await client.transferCancel({ transfer_id: someTransferId });

If successful, the transfer’s status will move to cancelled. You’ll get a webhook event for this. Remember to also handle any business logic (e.g. mark invoice as not paid).

Issuing Refunds

A refund in Plaid Transfer specifically refers to returning funds to a customer for a debit that was already processed ￼. For example, if a customer paid $100 via ACH debit and you need to give it back (perhaps they returned the product), you can create a refund instead of manually sending a new transfer. The refund will push money from your ledger back to the user’s bank.

Key points about refunds:
	•	You can only refund debit transfers (money that came from the customer) ￼. You cannot “refund” a credit payout (if a merchant needs to return funds to you, that would be a new debit transfer from them).
	•	The refund amount can be equal or less than the original transfer amount (no more) ￼. Partial refunds are allowed.
	•	Refunds draw from the available ledger balance of the same ledger that received the original funds ￼. This means if the money from the customer isn’t fully settled or has been withdrawn, you may not have funds to cover the refund. If insufficient, the refund will be rejected.
	•	There’s no mandatory waiting period imposed by Plaid to refund, but be cautious: if you refund before the original debit fully settles, you risk the scenario where the debit later returns NSF and you already gave a refund. (Plaid notes that ACH debits can return as unauthorized up to 60 days later ￼, though that’s rare. Insufficient funds returns typically come back within 2-3 days.)

To create a refund via API, call /transfer/refund/create with the original transfer_id and the refund amount. Example:

// Refund a $50 portion of a $100 transfer
await client.transferRefundCreate({
  transfer_id: originalTransferId,
  amount: "50.00"
});

The response will include a refund_id and status. Plaid will then initiate an ACH credit back to the customer’s account. You will also see events like refund.posted, refund.settled, or refund.failed via webhooks ￼.

If needed, you can cancel a refund with /transfer/refund/cancel before it’s sent for processing ￼. This works similarly to transfer cancel.

In the Plaid Dashboard, you have the option to manually trigger refunds for a transfer as well (for convenience) ￼.

Handling Returns (Customer-Initiated)

Sometimes a user might dispute an ACH debit (claim it was unauthorized) or their bank rejects it for other reasons. These come in as transfer returns (event returned as discussed). While not “refunds” in the Plaid API sense, you should treat them as the money going back to the user. Common ACH return codes:
	•	R01 – Insufficient Funds
	•	R02 – Account Closed
	•	R03 – No Account/Unable to Locate
	•	R05 / R07 / R10 – Unauthorized (these indicate the account holder disputed the debit).

When you receive a returned event, the transfer.status becomes returned and funds will be pulled out of your ledger to return to the user’s bank ￼. You should update the payment record (perhaps mark it as failed) and likely notify the user or merchant. In many cases, you might decide to retry (for R01 NSF, maybe try again the next day or allow the user to update funds) — Plaid doesn’t automatically retry debits, so you’d create a new transfer or prompt a different payment method.

Optional: Plaid Transfer UI Integration

Plaid offers a Transfer UI, a drop-in front-end component that can simplify user authorization for ACH payments. This is an optional enhancement on top of the API flows we’ve discussed. With Transfer UI, Plaid handles the UI/UX of confirming payment details and capturing NACHA authorization from the end-user, which can reduce your compliance overhead.

What Transfer UI Does: It presents the user with a confirmation screen showing the payment amount, source, and destination accounts, and obtains their explicit authorization (compliant with NACHA requirements for ACH web debits) ￼. It can handle both one-time payments and disbursements in the UI flow. Under the hood, Transfer UI uses a concept of a transfer intent to tie together the UI and backend transfer creation.

Limitations: Transfer UI currently does not support recurring transfers or the Platform Payments (originator) features ￼. It’s mainly for single ACH payments where your platform is the primary party.

Integration at a high level:
	1.	Create a Link customization in the Plaid Dashboard that has Account Select v2 enabled and is tailored for Transfer UI (e.g., to limit to one account selection) ￼.
	2.	Create a transfer intent: Call /transfer/intent/create on your backend to create an intent object, providing amount, description, source/dest etc. ￼. This will perform an authorization behind the scenes and return a transfer_intent_id.
	3.	Create a Link token with the intent: Call /link/token/create including the transfer_intent_id (in the transfer.intent_id field) and specify products: ["transfer"] ￼. If you already have an access_token for the user’s account, include it here to skip login; if not, the user will link a new account in the flow.
	4.	Launch Plaid Link (Transfer UI): On the frontend, initialize Link with this token. The user will see the UI to select the account (if not pre-selected) and confirm the payment.
	5.	On success: After the user completes the Transfer UI flow, Plaid will automatically create the transfer (no separate /transfer/create call needed from you). You will get a onSuccess callback with a transfer_id that was created. You should verify this and then continue your app logic (e.g., show a confirmation to user).

The benefit is that Plaid handles the intermediate steps and ensures you have a compliant authorization log. It’s especially useful if you want to minimize custom front-end development for the payment confirmation step. If you choose not to use Transfer UI, make sure you gather the user’s ACH authorization via your own interface (for example, have them check a box agreeing to terms or present a summary of the ACH debit) since NACHA requires proof of authorization for web-initiated debits.

Troubleshooting Tips and Best Practices

Implementing ACH transfers can be complex. Here are some tips and common issues to watch out for:
	•	Plaid Item issues: If transfers suddenly start failing with ITEM_LOGIN_REQUIRED rationale or user complaints, it could be the user’s bank connection is broken (credentials changed, etc.). Catch the user_action_required decision during authorization and guide the user through Link update mode ￼. Proactively, you might monitor for webhook errors from Plaid Item updates (though Plaid Signal or other products could help, too).
	•	Transfer Limits: Initially, Plaid sets conservative daily/monthly limits on your account. A transfer authorization that would exceed your limit is auto-declined ￼. If you plan to scale up volume, you may need to request higher limits from Plaid. Use /transfer/metrics/get to monitor your usage vs limits programmatically ￼.
	•	ACH Failures (Returns): Not all failures are under your control, but you can reduce them by:
	•	Using Plaid’s Balance product or the real-time balance check at authorization time (Plaid automatically checks balance during /transfer/authorization/create when possible). If an account has insufficient funds, Plaid might decline upfront, saving a return.
	•	Ensuring users provide a checking account (not a savings with limited transactions or a credit card account – Plaid Link’s Auth should mostly handle this).
	•	If an ACH is returned NSF (R01), consider notifying the customer and retrying with their consent. You’ll need to create a new transfer (the same transfer_id cannot be retried once returned).
	•	Platform-specific gotchas: If you’re a reseller/platform:
	•	Always use the correct API keys for each step (end-customer keys for linking user accounts, your keys for transfers) ￼.
	•	Include originator_client_id on every transfer-related call once originators are in use – forgetting this could result in transfers going to your default ledger unintentionally.
	•	Use Plaid’s Partner Sandbox endpoints to test originator flows. In Sandbox, you can call /transfer/originator/create directly to simulate an approved merchant ￼.
	•	Webhook reliability: If you don’t receive a webhook (perhaps a network issue), you can periodically call /transfer/event/sync without an after_id to fetch recent events ￼. Build retry logic for your webhook handler in case of transient failures, and log all incoming webhooks for auditing.
	•	Bank statement description: Ensure your Plaid Transfer application info (company name, phone) is correct, as these appear on statements along with your transfer description ￼. A clear description (e.g. “ShiFi Payment” or “ShiFi Refund”) helps users recognize charges and can reduce disputes.
	•	Testing in Sandbox: Plaid’s Sandbox lets you simulate various scenarios:
	•	Use /sandbox/transfer/simulate to fast-forward a transfer through states (posted, settled, returned) ￼.
	•	/sandbox/transfer/fire_webhook can trigger a webhook event to test your handler ￼.
	•	There are even sandbox commands to simulate sweeps and refunds ￼. Take advantage of these to test your end-to-end flows (e.g., simulate an NSF return and see if your system handles it correctly).
	•	Time zones and cutoff: Remember all Plaid cutoff times are in Eastern Time. If ShiFi operates in multiple time zones, consider converting or clearly documenting the latest local time for same-day transfers.
	•	Logging and Idempotency: Log Plaid request IDs (request_id in API responses) for support/troubleshooting with Plaid. If a transfer create call times out or you’re unsure of its success, use idempotency by providing a idempotency_key (Plaid’s Transfer API supports this in the request body) or check /transfer/list for a new transfer before retrying to avoid duplicate ACH entries.

By following this guide and using the Plaid API features effectively, ShiFi can reliably move money between customers and merchants, whether it’s a one-time purchase or a recurring payment plan. Plaid Transfer provides the rails (ACH, and optionally real-time payments) and risk checks, while ShiFi maintains control over the user experience and business logic.

References:
	•	Plaid Transfer API – Authorization and creation flow ￼ ￼
	•	Plaid Transfer API – Recurring transfers setup ￼ ￼
	•	Plaid Transfer API – ACH processing windows and cut-off times ￼ ￼
	•	Plaid Transfer Docs – Bank statement descriptor format ￼ ￼
	•	Plaid Transfer Docs – Cancelling transfers ￼
	•	Plaid Transfer Docs – Plaid Ledger and sweeps explanation ￼ ￼
	•	Plaid Transfer Docs – Refunds and timing considerations ￼ ￼
	•	Plaid Transfer UI – Overview and integration steps ￼ ￼
	•	Plaid Platform Payments – Using originator IDs (beta) ￼ ￼
	•	Plaid Transfer Webhooks – Using event sync for updates ￼ ￼